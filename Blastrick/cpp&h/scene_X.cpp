// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//
// Xシーン処理の説明[scene_X.cpp]
// Author : Koki Nishiyama
//
// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//
// インクルードファイル
//
// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#include "scene_X.h"
#include "manager.h"
#include "debugproc.h"
#include "game.h"
#include "floor.h"
#include "shadow_mapping.h"
#include "collision.h"

// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//
// 静的変数宣言
//
// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// コンストラクタ処理
// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
CScene_X::CScene_X()
{
	m_pXmodel.pMesh = NULL;										// メッシュ情報へのポインタ
	m_pXmodel.pBuffMat = NULL;									// マテリアル情報へのポインタ
	m_pXmodel.nNumMat = NULL;									// マテリアルの数
	m_pXmodel.ppTexture = NULL;									// テクスチャー
	m_pXmodel.vtxMinMaterials = D3DXVECTOR3(0.0f,0.0f,0.0f);	// 最少頂点
	m_pXmodel.vtxMaxMaterials = D3DXVECTOR3(0.0f, 0.0f, 0.0f);	// 最大頂点
	m_pXmodel.pos = D3DXVECTOR3(0.0f, 0.0f, 0.0f);				// 位置
	m_pXmodel.posDest = D3DXVECTOR3(0.0f, 0.0f, 0.0f);			// 目標位置
	m_pXmodel.rot = D3DXVECTOR3(0.0f, 0.0f, 0.0f);				// 回転
	m_pXmodel.rotDest = D3DXVECTOR3(0.0f, 0.0f, 0.0f);			// 目的回転
	m_pXmodel.size = D3DXVECTOR3(0.0f, 0.0f, 0.0f);				// サイズ
	m_pXmodel.nParent = 0;										// 親
}

// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// イニシャライザコンストラクタ
// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
CScene_X::CScene_X(ACTOR actor) : CScene::CScene(actor,LAYER_3DOBJECT)
{
	m_pXmodel.pMesh = NULL;										// メッシュ情報へのポインタ
	m_pXmodel.pBuffMat = NULL;									// マテリアル情報へのポインタ
	m_pXmodel.nNumMat = NULL;									// マテリアルの数
	m_pXmodel.ppTexture = NULL;									// テクスチャー
	m_pXmodel.vtxMinMaterials = D3DXVECTOR3(0.0f, 0.0f, 0.0f);	// 最少頂点
	m_pXmodel.vtxMaxMaterials = D3DXVECTOR3(0.0f, 0.0f, 0.0f);	// 最大頂点
	m_pXmodel.pos = D3DXVECTOR3(0.0f, 0.0f, 0.0f);				// 位置
	m_pXmodel.posDest = D3DXVECTOR3(0.0f, 0.0f, 0.0f);			// 目標位置
	m_pXmodel.rot = D3DXVECTOR3(0.0f, 0.0f, 0.0f);				// 回転
	m_pXmodel.rotDest = D3DXVECTOR3(0.0f, 0.0f, 0.0f);			// 目的回転
	m_pXmodel.size = D3DXVECTOR3(0.0f, 0.0f, 0.0f);				// サイズ
	m_pXmodel.nParent = 0;										// 親
}

// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// デストラクタ処理
// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
CScene_X::~CScene_X()
{
}

// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// 初期化処理
// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void CScene_X::Init(void)
{
	m_pXmodel.pMesh = NULL;										// メッシュ情報へのポインタ
	m_pXmodel.pBuffMat = NULL;									// マテリアル情報へのポインタ
	m_pXmodel.nNumMat = NULL;									// マテリアルの数
	m_pXmodel.ppTexture = NULL;									// テクスチャー
	m_pXmodel.vtxMinMaterials = D3DXVECTOR3(0.0f, 0.0f, 0.0f);	// 最少頂点
	m_pXmodel.vtxMaxMaterials = D3DXVECTOR3(0.0f, 0.0f, 0.0f);	// 最大頂点
	m_pXmodel.pos = D3DXVECTOR3(0.0f, 0.0f, 0.0f);				// 位置
	m_pXmodel.posDest = D3DXVECTOR3(0.0f, 0.0f, 0.0f);			// 目標位置
	m_pXmodel.rot = D3DXVECTOR3(0.0f, 0.0f, 0.0f);				// 回転
	m_pXmodel.rotDest = D3DXVECTOR3(0.0f, 0.0f, 0.0f);			// 目的回転
	m_pXmodel.size = D3DXVECTOR3(0.0f, 0.0f, 0.0f);				// サイズ
	m_pXmodel.nParent = 0;										// 親

	// 当たり判定生成
	m_pCollision = CCollision::Create();
	m_pCollision->SetPos(&m_pXmodel.pos);
	m_pCollision->SetSize(D3DXVECTOR3(50.0f, 100.0f, 50.0f));
	m_pCollision->SetMove(NULL);
	m_pCollision->SetType(CCollision::OBJTYPE_ACTOR);
}

// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// 終了処理
// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void CScene_X::Uninit(void)
{
	// メッシュの開放
	if (m_pXmodel.pMesh != NULL)
	{
		m_pXmodel.pMesh = NULL;
	}

	// マテリアルの開放
	if (m_pXmodel.pBuffMat != NULL)
	{
		m_pXmodel.pBuffMat = NULL;
	}

	// テクスチャーのヌルに
	if (m_pXmodel.ppTexture != NULL)
	{
		m_pXmodel.ppTexture = NULL;
	}
	if (m_pCollision != NULL)
	{
		m_pCollision = NULL;
	}
}

// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// 更新処理
// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void CScene_X::Update(void)
{
	/*
	// 変数宣言
	CFloor * pFloor = NULL;	// 床

	for (int nCntFloor = 0; nCntFloor < CScene::GetMaxLayer(LAYER_3DOBJECT); nCntFloor++)
	{
		// 床の情報を取得
		if (pFloor = (CFloor *)CScene::GetActor(ACTOR_FLOOR, LAYER_3DOBJECT, nCntFloor)) break;
	}
	m_pXmodel.pos.y = pFloor->GetHeight(m_pXmodel.pos);
	*/
}

// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// 描画処理
// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void CScene_X::Draw(void)
{
	// 変数宣言
	LPDIRECT3DDEVICE9	pDevice = CManager::GetRenderer()->GetDevice();

	D3DXMATRIX			mtxRot, mtxTrans;		// 計算用マトリックス
	D3DXMATERIAL		*pMat;					// 現在のマテリアル保存
	D3DMATERIAL9		matDef;					// マテリアルデータのポインタ

	// ワールドマトリックスの初期化
	D3DXMatrixIdentity(&m_mtxWorld);

	// 回転を反映
	// スケールを反映
	D3DXMatrixRotationYawPitchRoll(&mtxRot,
		m_pXmodel.rot.y,
		m_pXmodel.rot.x,
		m_pXmodel.rot.z);

	// 行列の積(1:ワールド行列 = 2:ワールド行列 * 3:回転行列)
	D3DXMatrixMultiply(&m_mtxWorld,
		&m_mtxWorld, &mtxRot);


	// 位置を反映 //
	// 平行移動行列作成(オフセット)
	D3DXMatrixTranslation(&mtxTrans,							// 総合の入れ物
		m_pXmodel.pos.x,
		m_pXmodel.pos.y,
		m_pXmodel.pos.z);

	// 行列の積(1:ワールド行列 = 2:ワールド行列 * 3:移動行列)
	D3DXMatrixMultiply(&m_mtxWorld,	// 1
		&m_mtxWorld,					// 2
		&mtxTrans);							// 3

	// シャドウマッピング
	CShadowmapping::Draw(
		pDevice,	// デバイス情報
		m_pXmodel,	// モデル情報
		m_mtxWorld	// マトリックス情報
	);
	// ワールドマトリックスの設定
	pDevice->SetTransform(D3DTS_WORLD, &m_mtxWorld);

	// 現在のマテリアルを取得
	pDevice->GetMaterial(&matDef);

	// マテリアル情報に対するポインタを取得
	pMat = (D3DXMATERIAL*)m_pXmodel.pBuffMat->GetBufferPointer();

	// カウントマテリアル
	for (int nCntMat = 0; nCntMat < (int)m_pXmodel.nNumMat; nCntMat++, pMat++)
	{
		// マテリアルの設定
		pDevice->SetMaterial(&pMat->MatD3D);

		// テクスチャー設定
		pDevice->SetTexture(0, m_pXmodel.ppTexture[nCntMat]);

		// 描画
		m_pXmodel.pMesh->DrawSubset(nCntMat);
	}

	// マテリアルをデフォルトに戻す
	pDevice->SetMaterial(&matDef);
}

#ifdef _DEBUG
// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// デバッグ表示
// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void CScene_X::Debug(void)
{
}
#endif // _DEBUG

// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// 作成処理
// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
CScene_X * CScene_X::Create()
{
	// 変数宣言
	CScene_X * pScene_Two;		// シーン3Dクラス

	// メモリの生成(初め->基本クラス,後->派生クラス)
	pScene_Two = new CScene_X(ACTOR_X);

	// 初期化処理
	pScene_Two->Init();
	
	// 生成したオブジェクトを返す
	return pScene_Two;
}

// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// 位置設定
// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void CScene_X::SetPos(D3DXVECTOR3 &pos)
{
	m_pXmodel.pos = pos;
}

// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// 角度設定
// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void CScene_X::SetRot(D3DXVECTOR3 &rot)
{
	m_pXmodel.rot = rot;
}

// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Xモデル取得処理
// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
XMODEL & CScene_X::GetXModel(void)
{
	return m_pXmodel;
}

// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// 位置情報処理
// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
D3DXVECTOR3 & CScene_X::GetPos(void)
{
	return m_pXmodel.pos;
}

// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// 回転情報処理
// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
D3DXVECTOR3 & CScene_X::GetRot(void)
{
	return m_pXmodel.rot;
}

// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// モデル情報処理
// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void CScene_X::BindModel(XMODEL const & XModel)
{
	m_pXmodel = XModel;
}
