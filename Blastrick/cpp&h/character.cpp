// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//
// キャラクター処理 [character.cpp]
// Author : KOKI NISHIYAMA
//
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#include "character.h"
#include "floor.h"
#include "input.h"
#include "collider.h"
#include "collision.h"
#include "3Dparticle.h"
#include "score.h"

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//
// マクロ定義
//
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#define CHARACTER_KEYMOVE (1)							// キー移動
#define CHARACTER_G (0.5f)								// 重力
#define CHARACTER_RESISTANCE (0.5f)						// 抵抗力
#define CHARACTER_STATUS_FILE ("data/LOAD/status.csv")	// ファイル名

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//
// 静的変数宣言
//
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
MODEL_ALL	*CCharacter::m_modelAll[CHARACTER_MAX] = {};		// モデル全体の情報
CModel_info	*CCharacter::m_model_info[CHARACTER_MAX] = {};		// モデル情報
int			CCharacter::m_NumModel[CHARACTER_MAX] = {};			// 最大モデル数
CCharacter::STATUS CCharacter::m_sStatus[CHARACTER_MAX] = {};	// キャラクターすべてのスタータス情報

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// オーバーローバーコンストラクタ処理
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
CCharacter::CCharacter() : CScene::CScene(ACTOR_CHARACTER, LAYER_3DOBJECT)
{
	m_character = CHARACTER_PLAYER;					// キャラクター
	m_pos = D3DXVECTOR3(0.0f, 0.0f, 0.0f);			// 位置
	m_posold = D3DXVECTOR3(0.0f, 0.0f, 0.0f);		// 前の位置
	m_move = D3DXVECTOR3(0.0f, 0.0f, 0.0f);			// 移動量
	m_rot = D3DXVECTOR3(0.0f, 0.0f, 0.0f);			// 現在回転量
	m_rotLast = D3DXVECTOR3(0.0f, 0.0f, 0.0f);		// 向きたい方向
	m_rotbetween = D3DXVECTOR3(0.0f, 0.0f, 0.0f);	// 回転の差分
	m_size = D3DXVECTOR3(0.0f, 0.0f, 0.0f);			// キャラクターのサイズ
	m_nMotiontypeOld = 0;							// 前回のモーションタイプ
	m_nMotiontype = 0;								// モーションタイプ
	m_keyinfoCnt = 0;								// キー情報のカウント
	m_nFrame = 0;									// フレームカウント
	m_nSlow = 1;									// スロー
	m_nMaxMotion = 0;								// 最大モーション数
	m_blust = BLUST_STOP;							// 吹っ飛び方
	m_nIDWho = 0;									// 敵か味方か
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// イニシャライザオーバーローバーコンストラクタ処理
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
CCharacter::CCharacter(ACTOR actor) : CScene::CScene(actor, LAYER_CHARACTER)
{
	m_character = CHARACTER_PLAYER;					// キャラクター
	m_pos = D3DXVECTOR3(0.0f,0.0f,0.0f);			// 位置
	m_posold = D3DXVECTOR3(0.0f, 0.0f, 0.0f);		// 前の位置
	m_move = D3DXVECTOR3(0.0f, 0.0f, 0.0f);			// 移動量
	m_rot = D3DXVECTOR3(0.0f, 0.0f, 0.0f);			// 現在回転量
	m_rotLast = D3DXVECTOR3(0.0f, 0.0f, 0.0f);		// 向きたい方向
	m_rotbetween = D3DXVECTOR3(0.0f, 0.0f, 0.0f);	// 回転の差分
	m_size = D3DXVECTOR3(0.0f, 0.0f, 0.0f);			// キャラクターのサイズ
	m_nMotiontypeOld = 0;							// 前回のモーションタイプ
	m_nMotiontype = 0;								// モーションタイプ
	m_keyinfoCnt = 0;								// キー情報のカウント
	m_nFrame = 0;									// フレームカウント
	m_nSlow = 1;									// スロー
	m_nMaxMotion = 0;								// 最大モーション数
	m_blust = BLUST_STOP;							// 吹っ飛び方
	m_nIDWho = 0;									// 敵か味方か
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// デストラクタ処理
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
CCharacter::~CCharacter()
{
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// 初期化処理
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void CCharacter::Init()
{
	// モデルのメモリ確保
	m_pModel = new CModel[m_NumModel[m_character]];

	// キャラクターの設定
	for (int nCntModel = 0; nCntModel < m_NumModel[m_character]; nCntModel++)
	{
		// キャラクター情報渡し
		m_pModel[nCntModel].Init();
		m_pModel[nCntModel].BindModel(
			m_model_info[m_character][nCntModel].GetXModel(),
			m_modelAll[m_character]->pModel_offset[nCntModel]
		);
		// モーション設定
		m_pModel[nCntModel].SetMotion(
			m_modelAll[m_character]->pMotion[m_nMotiontype].KeyInfo[m_keyinfoCnt].Key[nCntModel],
			m_modelAll[m_character]->pMotion[m_nMotiontype].KeyInfo[m_keyinfoCnt].nFrame * m_nSlow);

		// すべての親以外
		if (nCntModel != 0)
		{
			// 親情報設定
			m_pModel[nCntModel].SetParent(&m_pModel[m_modelAll[m_character]->pModel_offset[nCntModel].nParent]);
		}
	}
	// 敵か味方か
	if (m_character == CHARACTER_PLAYER)
	{
		m_nIDWho = 0;
	}
	else
	{
		m_nIDWho = 1;
	}

	// ステータスの反映
	m_Status.nMaxLife = m_sStatus[m_character].nMaxLife;
	m_Status.nLife = m_Status.nMaxLife;
	m_Status.nMaxMP = m_sStatus[m_character].nMP;
	m_Status.nMP = m_Status.nMaxMP;
	m_Status.nAttack = m_sStatus[m_character].nAttack;

	// 当たり判定生成
	m_pCollision = CCollision::Create();
	m_pCollision->SetPos(&m_pos);
	m_pCollision->SetSize(D3DXVECTOR3(30.0f,200.0f, 30.0f));
	m_pCollision->SetMove(&m_move);
	m_pCollision->SetType(CCollision::OBJTYPE_ACTOR);
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// 終了処理
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void CCharacter::Uninit(void)
{
	// ヌルチェック
	if (m_pModel != NULL)
	{
		delete[] m_pModel;
		m_pModel = NULL;
	}
	if (m_pCollision != NULL)
	{
		m_pCollision->Release();
		m_pCollision = NULL;
	}
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// 更新処理
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void CCharacter::Update(void)
{
	// 仮
#ifdef _DEBUG
	if (CManager::GetKeyboard()->GetKeyboardPress(DIK_Y))
	{
		m_Status.nLife -= 10;		// HP減少
		m_bDamage = true;
	}
#endif // _DEBUG

	// 移動
	Move();
	// モーション
	Motion();
	// 攻撃判定
	AttackCollision();
	// 無敵時間
	InviTime();
	// モデル更新
	ModelUpdate();
	// 状態
	State();
	// 高さ
	GetFloorHeight();
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// 次のモーション設定処理
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void CCharacter::NextKeyMotion(void)
{
	for (int nCntModel = 0; nCntModel < m_NumModel[m_character]; nCntModel++)
	{
		// ヌルチェック
		if (&m_pModel[nCntModel] != NULL)
		{
			// モーション設定
			m_pModel[nCntModel].SetMotion(
				m_modelAll[m_character]->pMotion[m_nMotiontype].KeyInfo[m_keyinfoCnt].Key[nCntModel],
				m_modelAll[m_character]->pMotion[m_nMotiontype].KeyInfo[m_keyinfoCnt].nFrame * m_nSlow);
		}
	}
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// 移動処理
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void CCharacter::Move(void)
{
	// 現在回転差分
	m_rotbetween = m_rotLast - m_rot;

	// 限度調整
	m_rotbetween.x = CCalculation::Rot_One_Limit(m_rotbetween.x);
	m_rotbetween.y = CCalculation::Rot_One_Limit(m_rotbetween.y);
	m_rotbetween.z = CCalculation::Rot_One_Limit(m_rotbetween.z);

	// 回転移動
	m_rot += m_rotbetween * 0.1f;

	// 限度調整
	m_rot.x = CCalculation::Rot_One_Limit(m_rot.x);
	m_rot.y = CCalculation::Rot_One_Limit(m_rot.y);
	m_rot.z = CCalculation::Rot_One_Limit(m_rot.z);
	
	// 移動
	m_move.y -= 1;
	m_pos += m_move;
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// モーション処理
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void CCharacter::Motion(void)
{
	// フレームカウントアップ
	m_nFrame++;
	// モーションタイプが変化
	// 初期化
	if (m_nMotiontype != m_nMotiontypeOld)
	{
		m_nFrame = 0;		// フレームキー情報のカウント
		m_keyinfoCnt = 0;	// キー情報のカウント
		// 次のモーション設定
		NextKeyMotion();
	}
	// モーションの保存
	m_nMotiontypeOld = m_nMotiontype;
	// フレーム数が同じになったら
	if (m_nFrame == m_modelAll[m_character]->pMotion[m_nMotiontype].KeyInfo[m_keyinfoCnt].nFrame * m_nSlow)
	{
		// 初期化
		m_nFrame = 0;	// フレーム
		// カウントアップ
		m_keyinfoCnt++;

		// キー情報が超えたら
		if (m_keyinfoCnt >= m_modelAll[m_character]->pMotion[m_nMotiontype].nNumKey)
		{
			// ループしないとき
			if (m_modelAll[m_character]->pMotion[m_nMotiontype].nLoop == 0)
			{
				m_nMotiontype = 0;	// モーションタイプ
			}
			// 初期化
			m_keyinfoCnt = 0;				// キー情報
			m_Status.bAttack = false;		// 攻撃状態
		}
		// 次のモーション設定
		NextKeyMotion();
	}
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// 攻撃の判定処理
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void CCharacter::AttackCollision(void)
{
	// 攻撃状態でなければ関数を抜ける
	if(!m_Status.bAttack)
	{ 
		return;
	}
	// 範囲内以外なら関数を抜ける
	else if (m_nFrame < m_modelAll[m_character]->pMotion[m_nMotiontype].Collision_StartFram ||
		m_nFrame >= m_modelAll[m_character]->pMotion[m_nMotiontype].Collision_EndFram)
	{
		return;
	}
	// 変数宣言
	CCharacter * pCharacter = NULL;	// 床
	D3DXVECTOR3 pos;				// 位置
	// 当たり判定の位置の設定 
	D3DXVec3TransformCoord(
		&pos,
		&m_modelAll[m_character]->pMotion[m_nMotiontype].Collision_Ofset,
		&m_pModel[m_modelAll[m_character]->pMotion[m_nMotiontype].Collision_nParts].GetMtx()
	);

	for (int nCntLayer = 0; nCntLayer < CScene::GetMaxLayer(CScene::LAYER_CHARACTER); nCntLayer++)
	{
		// 情報取得
		pCharacter = (CCharacter*)CScene::GetScene(CScene::LAYER_CHARACTER, nCntLayer);	// キャラクター
		// 存在しているかどうか
		if (pCharacter == NULL || 
			pCharacter == this)
		{
			continue;
		}
		// 判定を適用するかどうか
		else if (this->m_character == pCharacter->m_character ||	// 同族か
			pCharacter->m_Status.bInvincible)						// 無敵状態ではないか
		{
			continue;
		}
		// 球の当たり判定
		if (CCalculation::Collision_Circle(
			pos,																// 位置
			m_modelAll[m_character]->pMotion[m_nMotiontype].Collision_Radius,	// 範囲
			pCharacter->GetPos(),												// キャラクター位置
			100.0f																// 範囲
		))
		{
			// ダメージ処理
			pCharacter->AplayDamage(
				m_pos,
				(BLUST)m_modelAll[m_character]->pMotion[m_nMotiontype].KeyInfo[m_keyinfoCnt].nBlust,
				m_modelAll[m_character]->pMotion[m_nMotiontype].Collision_Damage + m_Status.nAttack
			);
		}
	}

	// 当たり判定の回数がない場合関数を抜ける
	if (m_modelAll[m_character]->pMotion[m_nMotiontype].KeyInfo[m_keyinfoCnt].nNumCollision == 0)
	{
		return;
	}
	if (m_nFrame % m_modelAll[m_character]->pMotion[m_nMotiontype].KeyInfo[m_keyinfoCnt].nMaxCollisiontime == 0)
	{
		// 変数宣言
		CCharacter * pCharacter = NULL;	// 床
		// 情報取得
		for (int nCntLayer = 0; nCntLayer < CScene::GetMaxLayer(CScene::LAYER_CHARACTER); nCntLayer++)
		{
			pCharacter = (CCharacter*)CScene::GetScene(CScene::LAYER_CHARACTER, nCntLayer);
			// 存在しているかどうか
			if (pCharacter == NULL)
			{
				continue;
			}
			// 判定を適用するかどうか
			else if (this->m_character == pCharacter->GetCharacter())		// 同族か
			{
				continue;
			}
			pCharacter->SetInvi(false);
		}
	}
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// 無敵時間処理
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void CCharacter::InviTime(void)
{
	// 無敵時間
	if (!m_Status.bInvincible)
	{
		return;
	}
	else if (m_Status.nInviTime >= 60)
	{
		m_Status.nInviTime = 0;
		m_Status.bInvincible = false;
	}
	// カウントアップ
	m_Status.nInviTime++;
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// モデルの更新処理
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void CCharacter::ModelUpdate(void)
{
	for (int nCntModel = 0; nCntModel < m_NumModel[m_character]; nCntModel++)
	{
		// ヌルチェック
		if (&m_pModel[nCntModel] != NULL)
		{
			/*
			// モーション設定
			m_pModel[nCntModel].SetMotion(
				m_modelAll[m_character]->pMotion[m_nMotiontype].KeyInfo[m_keyinfoCnt].Key[nCntModel],
				m_modelAll[m_character]->pMotion[m_nMotiontype].KeyInfo[m_keyinfoCnt].nFrame * m_nSlow);
				*/
			// 更新
			m_pModel[nCntModel].Update();
		}
	}
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// 状態処理
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void CCharacter::State(void)
{
	switch (m_Status.State)
	{
		// ノーマル
	case STATE_NORMAL:
		NormalState();
		break;
		// 攻撃直前
	case STATE_BEFORE_AT:
		Before_ATState();
		break;
		// 攻撃
	case STATE_ATTACK:
		AttackState();
		break;
		// 攻撃後
	case STATE_AFTER_AT:
		After_ATState();
		break;
		// ダメージ
	case STATE_DAMAGE:
		DamageState();
		break;
		// 死
	case STATE_DIE:
		DieState();
		break;
	default:
		break;
	}
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// 普通の状態
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void CCharacter::NormalState(void)
{
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// 攻撃前の状態
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void CCharacter::Before_ATState(void)
{
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// 攻撃状態
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void CCharacter::AttackState(void)
{

}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// 攻撃後の状態
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void CCharacter::After_ATState(void)
{
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// ダメージ状態
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void CCharacter::DamageState(void)
{
	m_pos += m_BlustMove;
	if (m_blust == BLUST_SLASH)
	{
		C3DParticle::Create(C3DParticle::OFFSET_ID_AWAYSMOKE, m_pos);
	}
	// ステートカウントアップ
	m_Status.nCntState++;
	// 1秒後
	if (m_Status.nCntState == DERAY_TIME(1))
	{
		m_Status.nCntState = 0;
		m_Status.nCntState = 0;
		m_Status.State = STATE_NORMAL;
		m_Status.fAlpha = 1;
		m_BlustMove.x = 0.0f;
		m_BlustMove.z = 0.0f;
		m_pCollision->SetUse(true);
	}
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// 死の状態
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void CCharacter::DieState(void)
{
	m_pos += m_BlustMove;
	if (m_blust == BLUST_SLASH)
	{
		C3DParticle::Create(C3DParticle::OFFSET_ID_AWAYSMOKE, m_pos);
	}

	// ステートカウントアップ
	m_Status.nCntState++;
	// 1秒後
	if (m_Status.nCntState == DERAY_TIME(1))
	{
		m_Status.nCntState = 0;
		m_Status.State = STATE_NORMAL;
		m_Status.fAlpha = 1;
		m_BlustMove = D3DVECTOR3_ZERO;
		m_pCollision->SetUse(true);
	}

	m_Status.nCntState++;
	// 2秒後
	if (m_Status.nCntState == DERAY_TIME(2))
	{
		m_Status.nCntState = 0;
		m_Status.fAlpha = 1;
		m_Status.State = STATE_NORMAL;
		C3DParticle::Create(
			C3DParticle::OFFSET_ID_GET,
			m_pos
		);
		if (m_character != CHARACTER_PLAYER)
		{
			// 変数宣言
			CScore *pScore = NULL;
			// 情報取得
			for (int nCntLayer = 0; nCntLayer < CScene::GetMaxLayer(CScene::LAYER_UI); nCntLayer++)
			{
				if ((pScore = (CScore*)CScene::GetActor(CScene::ACTOR_SCORE, CScene::LAYER_UI, nCntLayer)) != NULL) break;
			}
			if (pScore != NULL)
			{
				pScore->SetScore(100);
			}
		}
		Release();
	}
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// ノックバック
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void CCharacter::NockBack(void)
{

}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// 死
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void CCharacter::Dead(void)
{
	Release();
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// 描画処理
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void CCharacter::Draw(void)
{
	D3DXMATRIX	mtxRot, mtxTrans;	// 計算用マトリックス

	// ワールドマトリックスの初期化
	D3DXMatrixIdentity(&m_mtxWorld);

	// 回転を反映
	// スケールを反映
	D3DXMatrixRotationYawPitchRoll(&mtxRot,
		m_rot.y,
		m_rot.x,
		m_rot.z);

	// 行列の積(1:ワールド行列 = 2:ワールド行列 * 3:回転行列)
	D3DXMatrixMultiply(&m_mtxWorld,
		&m_mtxWorld, &mtxRot);


	// 位置を反映 //
	// 平行移動行列作成(オフセット)
	D3DXMatrixTranslation(&mtxTrans,	// 総合の入れ物
		m_pos.x,
		m_pos.y,
		m_pos.z);

	// 行列の積(1:ワールド行列 = 2:ワールド行列 * 3:移動行列)
	D3DXMatrixMultiply(&m_mtxWorld,	// 1
		&m_mtxWorld,				// 2
		&mtxTrans);					// 3

	// モデル
	for (int nCntModel = 0; nCntModel < m_NumModel[m_character]; nCntModel++)
	{
		// ヌルチェック
		if (&m_pModel[nCntModel] != NULL)
		{
			m_pModel[nCntModel].Draw(
				m_mtxWorld,
				m_Status.fAlpha
				);
		}
	}
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// ダメージ計算
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void CCharacter::AplayDamage(
	D3DXVECTOR3 const &pos,
	BLUST		const &bBlust,
	int			const &nDamage
)
{
	// 変数宣言
	D3DXVECTOR3 diffpos;
	float	fAngle;

	// 自分と相手との距離
	diffpos = m_pos - pos;			// 
	m_move = D3DVECTOR3_ZERO;		// 移動量を初期化
	m_Status.nLife -= nDamage;		// HP減少
	m_Status.nCntState = 0;			// ステートカウント初期化
	m_Status.State = STATE_DAMAGE;	// ダメージ状態
	m_Status.bInvincible = true;	// 無敵状態
	m_bDamage = true;				// ダメージ判定
	// 死亡条件
	if (m_Status.nLife < 0)
	{
		m_Status.State = STATE_DIE;
	}
	/* 吹っ飛び方 */
	// 止まる
	if (bBlust == BLUST_STOP)
	{
		m_BlustMove.y = 3.0f;	// 反動
	}
	// 横に吹っ飛ぶ
	else if (bBlust == BLUST_SLASH)
	{
		// 自分から見て相手がいる角度
		fAngle = (atan2f(diffpos.x, diffpos.z));
		m_BlustMove.x = sinf(fAngle) * 13.0f;
		m_BlustMove.z = cosf(fAngle) * 13.0f;
		m_BlustMove.y = 18.0f;				// 反動
		m_pCollision->SetUse(false);		// 当たり判定を消す
		C3DParticle::Create(C3DParticle::OFFSET_ID_SHOCKWAVE,m_pos);
	}
	// 上に吹っ飛ぶ
	else if(bBlust == BLUST_UP)
	{
		// 自分から見て相手がいる角度
		fAngle = (atan2f(diffpos.x, diffpos.z));
		m_BlustMove.x = sinf(fAngle) * 5.0f;
		m_BlustMove.z = cosf(fAngle) * 5.0f;
		m_BlustMove.y = 20.0f;				// 反動
		m_pCollision->SetUse(false);	// 当たり判定を消す
	}
	// 攻撃されているほうへ近づく
	else if (bBlust == BLUST_NEAR)
	{
		// 相手から見て自分がいる角度
		fAngle = (atan2f(-diffpos.x, -diffpos.z));
		m_BlustMove.x = sinf(fAngle) * 0.5f;
		m_BlustMove.z = cosf(fAngle) * 0.5f;
		m_BlustMove.y = 7.0f;				// 反動
	}
	// パーティクル生成
	C3DParticle::Create(
		C3DParticle::OFFSET_ID_CROSSLINE,
		m_pos
	);
	// パーティクル生成
	C3DParticle::Create(
		C3DParticle::OFFSET_ID_STAR,
		m_pos
	);
	// ダメージ喰らった時の音
	CManager::GetSound()->PlaySound(CSound::LABEL_SE_SWORDSLASH1);

	
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// フィールドの高さを算出
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
bool CCharacter::GetFloorHeight(void)
{
	/*
	// 変数宣言
	CFloor * pFloor = NULL;	// 床
							// 情報取得
	for (int nCntLayer = 0; nCntLayer < CScene::GetMaxLayer(CScene::LAYER_3DOBJECT); nCntLayer++)
	{
		pFloor = (CFloor*)CScene::GetActor(CScene::ACTOR_FLOOR, CScene::LAYER_3DOBJECT, nCntLayer);	// 床
		if (pFloor != NULL)
		{
			// 床の高さを代入
			if (m_pos.y < pFloor->GetHeight(m_pos))
			{
				m_pos.y = pFloor->GetHeight(m_pos);
				m_move.y = 0;
				m_BlustMove = D3DVECTOR3_ZERO;
				return true;
			}
		}
	}

	*/
	if (m_pos.y <= 0)
	{
		m_BlustMove = D3DVECTOR3_ZERO;
		m_move.y = 0;
		m_pos.y = 0;
	}
	return false;
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// モーションのフレーム情報取得処理
// 1)キャラクターID、2)モーションID、3)現在のキーカウント
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
int CCharacter::GetMaxFrame(
	CHARACTER character,	// キャラクター
	int nMotionID,			// モーションID
	int nNowKeyCnt			// 現在のキーカウント
)
{
	// モーション全体のフレーム数
	if (nNowKeyCnt == -1)
	{
		return m_modelAll[character]->pMotion[nMotionID].nAllFrame;
	}
	// 一つのキー間のフレーム数
	return m_modelAll[character]->pMotion[nMotionID].KeyInfo[nNowKeyCnt].nFrame;
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// カメラタイプ取得処理
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
int CCharacter::GetCameraType(void)
{
	return m_modelAll[m_character]->pMotion[m_nMotiontype].KeyInfo[m_keyinfoCnt].nCameraType;
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// 重力処理
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void CCharacter::FagGravity(void)
{
	// 重力処理
	m_move.y -= 1.0f;
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// 目標回転設定処理
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void CCharacter::SetRotDest(D3DXVECTOR3 const & rotDest)
{
	m_rotLast = rotDest;
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// 目標回転量取得処理
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
D3DXVECTOR3 CCharacter::GetRotDest(void)
{
	return m_rotLast;
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// キャラクター設定処理
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void CCharacter::SetCharacter(CHARACTER const character)
{
	m_character = character;
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// モーション設定処理
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void CCharacter::SetMotion(int const nMotiontype)
{
	// ループ状態の時
	if (m_modelAll[m_character]->pMotion[m_nMotiontype].nLoop == 1)
	{
		m_nMotiontype = nMotiontype;
	}
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// 位置設定処理
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void CCharacter::SetPos(D3DXVECTOR3 const &pos)
{
	m_pos = pos;
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// 移動量設定処理
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void CCharacter::SetMove(D3DXVECTOR3 const & move)
{
	m_move = move;
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// 位置設定処理
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void CCharacter::SetRot(D3DXVECTOR3 const &rot)
{
	m_rot = rot;
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// 攻撃状態設定処理
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void CCharacter::SetAttack(bool bAttack)
{
	m_Status.bAttack = bAttack;
	// 変数宣言
	D3DXVECTOR3 pos;
	int nParts;
	nParts = m_modelAll[m_character]->pMotion[m_nMotiontype].Collision_nParts;
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// 状態設定処理
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void CCharacter::SetState(STATE const & state)
{
	m_Status.State = state;
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// 無敵状態設定処理
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void CCharacter::SetInvi(bool const bInvi)
{
	m_Status.bInvincible = bInvi;
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// キャラクター取得処理
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
CCharacter::CHARACTER CCharacter::GetCharacter(void)
{
	return m_character;
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// 位置取得処理
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
D3DXVECTOR3 &CCharacter::GetPos(void)
{
	return m_pos;
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// 移動量取得処理
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
D3DXVECTOR3 & CCharacter::GetMove(void)
{
	return m_move;
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// 回転取得処理
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
D3DXVECTOR3 &CCharacter::GetRot(void)
{
	return m_rot;
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// 回転取得処理
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
D3DXVECTOR3 *CCharacter::GetPartsRot(int const nModelID)
{
	// モデルの行列情報取得
	if (nModelID >= 0 ||
		nModelID < m_NumModel[m_character])
	{

		return &m_pModel[nModelID].GetRot();
	}
	// キャラクターの行列情報取得
	else if (nModelID == -1)
	{
		return &m_rot;
	}
#ifdef _DEBUG
	CCalculation::Messanger("キャラクターのモデルの回転情報がありません");
#endif // _DEBUG
	// 指定されたIDがない場合
	return &m_rot;
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// 位置取得処理
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
D3DXVECTOR3 *CCharacter::GetPartsPos(int const nModelID)
{
	// モデルの行列情報取得
	if (nModelID >= 0 ||
		nModelID < m_NumModel[m_character])
	{
		return &m_pModel[nModelID].GetPos();
	}
	// キャラクターの行列情報取得
	else if (nModelID == -1)
	{
		return &m_rot;
	}
#ifdef _DEBUG
	CCalculation::Messanger("キャラクターのモデルの回転情報がありません");
#endif // _DEBUG
	// 指定されたIDがない場合
	return &m_rot;
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// モーション番号取得処理
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
int CCharacter::GetMotion(void)
{
	return m_nMotiontype;
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// キーカウント取得処理
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
int CCharacter::GetKeyInfoCnt(void)
{
	return m_keyinfoCnt;
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// 行列取得処理
// -1はキャラクターの行列情報、0〜はモデルの行列情報
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
D3DXMATRIX * CCharacter::GetMatrix(int const nModelID)
{
	// モデルの行列情報取得
	if(nModelID >= 0 ||
		nModelID < m_NumModel[m_character])
	{
		return &m_pModel[nModelID].GetMtx();
	}
	// キャラクターの行列情報取得
	else if (nModelID == -1)
	{
		return &m_mtxWorld;
	}
#ifdef _DEBUG
	CCalculation::Messanger("キャラクターのモデルの行列情報がありません");
#endif // _DEBUG
	// 指定されたIDがない場合
	return &m_mtxWorld;
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// ステータス情報取得処理
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
CCharacter::STATUS & CCharacter::GetStatus(void)
{
	return m_Status;
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// 状態取得処理
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
CCharacter::STATE CCharacter::GetState(void)
{
	return m_Status.State;
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// 攻撃状態取得処理
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
bool CCharacter::GetAttack(void)
{
	return m_Status.bAttack;
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// 生成処理
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
CCharacter * CCharacter::Create(
	int const nMaxMotion,
	CHARACTER const character
	)
{
	// 変数宣言
	CCharacter * pCharacter;
	// メモリの生成(初め->基本クラス,後->派生クラス)
	pCharacter = new CCharacter();
	// 最大モーション数
	pCharacter->m_nMaxMotion = nMaxMotion;
	// キャラクター
	pCharacter->m_character = character;
	// 初期化処理
	pCharacter->Init();
	// 生成したオブジェクトを返す
	return pCharacter;
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// 読み込み処理
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void CCharacter::Load(
	CHARACTER const character,
	int const nMaxMotion,
	const char * file_name
)
{
	// 変数宣言
	LPDIRECT3DDEVICE9	pDevice = CManager::GetRenderer()->GetDevice();
	// モデルとモーション情報の生成
	m_modelAll[character] = new MODEL_ALL;
	// キャラクターのテクストデータの取得
	CModel_info::TextLoad(
		m_modelAll[character],
		nMaxMotion,								// モーション数
		m_NumModel[character],					// 最大モデル数
		file_name								// ファイル名
	);
	// モデル情報のz生成
	m_model_info[character] = new CModel_info[m_NumModel[character]];
	// キャラクターの保存
	for (int nCntModelLoad = 0; nCntModelLoad < m_NumModel[character]; nCntModelLoad++)
	{
		if(!m_model_info[character][nCntModelLoad].Load(
			pDevice,													// デバイス
			m_modelAll[character]->pModel_offset[nCntModelLoad].cXfile	// モデルパス
		) == S_OK)
			CCalculation::Messanger(m_modelAll[character]->pModel_offset[nCntModelLoad].cXfile);
	}
	// スタータス情報の読み込み
	LoadStatus();
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// ステータス情報読み込み処理
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
HRESULT CCharacter::LoadStatus(void)
{
	/*
	// ファイルポイント
	FILE *pFile;

	// 変数宣言
	int	nCntObj = 0;		// シャドウマッピングカウント
	char cRaedText[128];	// 文字として読み取り用
	char cHeadText[128];	// 比較するよう
	char cDie[128];			// 不必要な文字

	// ファイルが開かれていなかったら
	if ((pFile = fopen(CHARACTER_STATUS_FILE, "r")) == NULL)
	{// メッセージの表示
#ifdef _DEBUG
		CCalculation::Messanger("テキストファイルが見つかりませんでした");
#endif // _DEBUG
		return E_FAIL;
	}

	while (strcmp(cHeadText, "END") != 0)
	{
		// 初期化
		cHeadText[0] = '\0';
		fgets(cRaedText, sizeof(cRaedText), pFile);
		sscanf(cRaedText, "%s,%d,%d,%d,%d",
			&cDie,m_sStatus,
			&m_load[nCntObj].nType
		);

	}
	*/
	for (int nCntCharacter = 0; nCntCharacter < CHARACTER_MAX; nCntCharacter++)
	{
		m_sStatus[nCntCharacter].nMaxLife = 100;
		m_sStatus[nCntCharacter].nMaxMP = 100;
		m_sStatus[nCntCharacter].nAttack = 10;
	}
	return S_OK;
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// 読み込んだ情報を破棄処理
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void CCharacter::UnLoad(
	CHARACTER const character,
	int const nMaxMotion)
{
	// 変数宣言
	int	nCntMotion = 0;		// モーションカウント
	int	nCntKeySet = 0;		// フレーム数6

	// キャラクター情報の開放
	for (int nCntModelLoad = 0; nCntModelLoad < m_NumModel[character]; nCntModelLoad++)
	{
		m_model_info[character][nCntModelLoad].Unload();
	}
	// モデル情報の破棄
	delete[] m_model_info[character];
	m_model_info[character] = NULL;
	// モデル・モーションの破棄
	CModel_info::TextUnload(m_modelAll[character], nMaxMotion);
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// デバッグ表示
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#ifdef _DEBUG
void CCharacter::Debug(void)
{

}
#endif // _DEBUG

