// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//
// 静的オブジェクト処理の説明[staticobj.cpp]
// Author : Koki Nishiyama
//
// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//
// インクルードファイル
//
// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#include "staticobj.h"
#include "manager.h"
#include "debugproc.h"
#include "game.h"
#include "floor.h"
#include "shadow_mapping.h"

// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//
// 静的変数宣言
//
// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
CModel_info *			CStaticobj::m_pModel;		// モデル情報
vector<string>			CStaticobj::m_FilePass;		// ファイルのパスを参照
vector<ARRANGEMENTOBJ>	CStaticobj::m_pArrangeobj;	// 配置物情報

// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// コンストラクタ処理
// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
CStaticobj::CStaticobj() : CScene_X::CScene_X(ACTOR_STATICOBJ)
{
}

// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// デストラクタ処理
// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
CStaticobj::~CStaticobj()
{
}

// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// 初期化処理
// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void CStaticobj::Init(void)
{
	CScene_X::Init();
}

// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// 終了処理
// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void CStaticobj::Uninit(void)
{
	CScene_X::Uninit();
}

// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// 更新処理
// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void CStaticobj::Update(void)
{
	CScene_X::Update();
}

// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// 描画処理
// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void CStaticobj::Draw(void)
{
	CScene_X::Draw();
}

#ifdef _DEBUG
// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// デバッグ表示
// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void CStaticobj::Debug(void)
{
}
#endif // _DEBUG

// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// 作成処理
// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
CStaticobj * CStaticobj::Create()
{
	// 変数宣言
	CStaticobj * pStaticobj;		// シーン3Dクラス

	// メモリの生成(初め->基本クラス,後->派生クラス)
	pStaticobj = new CStaticobj();

	// 初期化処理
	pStaticobj->Init();
	
	// 生成したオブジェクトを返す
	return pStaticobj;
}

// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// 読み込んだ情報を生成
// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
HRESULT CStaticobj::LoadCreate()
{
	CStaticobj * pStaticobj;
	for (int nCntStaticobj = 0; nCntStaticobj < (signed)m_pArrangeobj.size(); nCntStaticobj++)
	{
		pStaticobj = CStaticobj::Create();
		pStaticobj->BindModel(m_pModel[m_pArrangeobj.at(nCntStaticobj).nType].GetXModel());
		pStaticobj->SetPos(m_pArrangeobj.at(nCntStaticobj).pos);
		pStaticobj->SetRot(m_pArrangeobj.at(nCntStaticobj).rot);
		pStaticobj = NULL;
	}
	return S_OK;
}

// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// リソース情報読み込む設定
// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
HRESULT CStaticobj::Load(void)
{
	// 変数宣言
	LPDIRECT3DDEVICE9	pDevice = CManager::GetRenderer()->GetDevice();
	LoadText();
	m_pModel = new CModel_info[m_FilePass.size()];
	for (int nCntModelLoad = 0; nCntModelLoad < (signed)m_FilePass.size(); nCntModelLoad++)
	{
		m_pModel[nCntModelLoad].Load(
			pDevice,								// デバイス
			m_FilePass.at(nCntModelLoad).c_str()	// モデルパス
		);
	}

	return S_OK;
}

// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// 読み込んだリソース情報を開放する
// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void CStaticobj::UnLoad(void)
{
	// モデルのリソース情報を開放する
	for (int nCntModelLoad = 0; nCntModelLoad < (signed)m_FilePass.size(); nCntModelLoad++)
	{
		m_pModel[nCntModelLoad].Unload();
	}
	// モデルの情報を開放する
	delete[] m_pModel;
	m_pModel = NULL;
	// ファイル名を開放する
	vector<string>().swap(m_FilePass);
	// 配置物情報を開放する
	vector<ARRANGEMENTOBJ>().swap(m_pArrangeobj);
}

// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Xモデル取得処理
// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
XMODEL & CStaticobj::GetXModel(void)
{
	return m_pModel->GetXModel();
}

// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// 配置情報を読み込む処理
// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
HRESULT CStaticobj::LoadText(void)
{
	// ファイルポイント
	FILE *pFile;

	// 変数宣言						
	char cRaedText[128];		// 文字として読み取り用
	char cHeadText[128];		// 比較するよう
	char cDie[128];				// 不必要な文字
	int nCntError = 0;			// エラーカウント
	char cFilePas[64];		// ファイルパス
	ARRANGEMENTOBJ arrangeobj;	// 配置物情報

	// ファイルが開かれていなかったら
	if ((pFile = fopen("data/LOAD/MAPPING/materials.txt", "r")) == NULL)
	{// メッセージの表示
#ifdef _DEBUG
		CCalculation::Messanger("テキストファイルが見つかりませんでした");
#endif // _DEBUG
		return E_FAIL;
	}
	// スクリプトが来るまでループ
	while (strcmp(cHeadText, "SCRIPT") != 0)
	{
		fgets(cRaedText, sizeof(cRaedText), pFile);	// 一文を読み込む
		sscanf(cRaedText, "%s", &cHeadText);		// 比較用テクストに文字を代入
		// ファイルのパス情報読み込み
		if (strcmp(cHeadText, "OBJ") == 0)
		{
			sscanf(cRaedText, "%s %s %s", &cDie, &cDie, &cFilePas);
			m_FilePass.push_back(cFilePas);
		}
		// エラーカウントをインクリメント
		nCntError++;
		if (nCntError > FILELINE_ERROW)
		{// エラー
			nCntError = 0;
			fclose(pFile);
			CCalculation::Messanger("エンドスクリプトがありません");
			return E_FAIL;
		}
	}

	// スクリプトだったら
	if (strcmp(cHeadText, "SCRIPT") == 0)
	{
		// エンドスクリプトが来るまでループ
		while (strcmp(cHeadText, "END_SCRIPT") != 0)
		{
			fgets(cRaedText, sizeof(cRaedText), pFile);
			sscanf(cRaedText, "%s", &cHeadText);

			// 改行だったら
			if (strcmp(cHeadText, "\n") == 0)
			{
			}

			// モデルセットが来たら
			else if (strcmp(cHeadText, "MATERIALSSET") == 0)
			{

				// エンドモデルセットが来るまでループ
				while (strcmp(cHeadText, "END_MATERIALSSET") != 0)
				{
					fgets(cRaedText, sizeof(cRaedText), pFile);
					sscanf(cRaedText, "%s", &cHeadText);

					// 親情報読み込み
					if (strcmp(cHeadText, "TYPE") == 0)
					{
						sscanf(cRaedText, "%s %s %d", &cDie, &cDie, &arrangeobj.nType);
					}

					// 位置情報読み込み
					else if (strcmp(cHeadText, "POS") == 0)
					{
						sscanf(cRaedText, "%s %s %f %f %f", &cDie, &cDie,
							&arrangeobj.pos.x,
							&arrangeobj.pos.y,
							&arrangeobj.pos.z);
					}

					// 回転情報読み込み
					else if (strcmp(cHeadText, "ROT") == 0)
					{
						sscanf(cRaedText, "%s %s %f %f %f", &cDie, &cDie,
							&arrangeobj.rot.x,
							&arrangeobj.rot.y,
							&arrangeobj.rot.z);
						m_pArrangeobj.push_back(ARRANGEMENTOBJ(arrangeobj.nType, arrangeobj.pos, arrangeobj.rot));
					}
					// エラーカウントをインクリメント
					nCntError++;
					if (nCntError > FILELINE_ERROW)
					{// エラー
						nCntError = 0;
						fclose(pFile);
						CCalculation::Messanger("エンドマテリアルセットがありません");
						return E_FAIL;
					}
				}
			}

			// エラーカウントをインクリメント
			nCntError++;
			if (nCntError > FILELINE_ERROW)
			{// エラー
				nCntError = 0;
				fclose(pFile);
				CCalculation::Messanger("エンドスクリプトがありません");
				return E_FAIL;
			}
		}
	}
	// ファイル閉
	fclose(pFile);
	return S_OK;
}
